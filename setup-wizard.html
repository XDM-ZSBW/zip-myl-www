<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🚀 MyL.Zip Setup Wizard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .wizard-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: 100%;
            overflow: hidden;
        }

        .wizard-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .wizard-header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .wizard-header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .wizard-content {
            padding: 40px;
        }

        .step {
            display: none;
        }

        .step.active {
            display: block;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .form-group input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group small {
            display: block;
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .email-requirement {
            color: #d32f2f !important;
            font-weight: 500;
            background: #ffebee;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #d32f2f;
            margin: 8px 0 !important;
        }
        
        .sync-key-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .sync-key-container input {
            flex: 1;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .sync-key-container button {
            white-space: nowrap;
            padding: 8px 12px;
            font-size: 12px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 2px solid #e1e5e9;
        }

        .btn-secondary:hover {
            background: #e9ecef;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .wizard-navigation {
            display: flex;
            gap: 15px;
            justify-content: space-between;
            margin-top: 30px;
        }

        .device-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 25px;
            border-left: 4px solid #667eea;
        }

        .device-info h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .device-info ul {
            list-style: none;
        }

        .device-info li {
            margin-bottom: 8px;
            font-size: 14px;
        }

        .device-info strong {
            color: #333;
        }

        /* Chat Interface Styles */
        .chat-interface {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 25px;
            border-left: 4px solid #28a745;
        }

        .chat-interface h3 {
            color: #28a745;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .chat-container {
            background: white;
            border-radius: 8px;
            border: 1px solid #e1e5e9;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .chat-messages {
            max-height: 200px;
            overflow-y: auto;
            padding: 15px;
            background: #fafafa;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            position: relative;
        }

        .message.user {
            background: #667eea;
            color: white;
            margin-left: 20px;
            text-align: right;
        }

        .message.system {
            background: #e9ecef;
            color: #333;
            margin-right: 20px;
        }

        .message.extension {
            background: #28a745;
            color: white;
            margin-right: 20px;
        }

        .message-time {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 3px;
        }

        .message-content {
            word-wrap: break-word;
        }

        .chat-input {
            display: flex;
            padding: 10px;
            background: white;
            border-top: 1px solid #e1e5e9;
        }

        .chat-input input {
            flex: 1;
            border: 1px solid #e1e5e9;
            border-radius: 4px;
            padding: 8px 12px;
            margin-right: 8px;
            font-size: 14px;
        }

        .chat-input input:focus {
            outline: none;
            border-color: #667eea;
        }

        .chat-input button {
            padding: 8px 16px;
            font-size: 14px;
            white-space: nowrap;
        }

        .chat-status {
            text-align: center;
            color: #666;
        }

        .chat-status.connected {
            color: #28a745;
        }

        .chat-status.disconnected {
            color: #dc3545;
        }

        /* Captcha Modal Styles */
        .captcha-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .captcha-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .captcha-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .captcha-header h2 {
            color: #333;
            font-size: 24px;
            margin-bottom: 10px;
        }

        .captcha-header p {
            color: #666;
            font-size: 16px;
        }

        .puzzle-container {
            margin-bottom: 25px;
            text-align: center;
        }

        .puzzle-question {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }

        .puzzle-canvas {
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            margin: 0 auto 20px;
            display: block;
        }

        .puzzle-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .puzzle-option {
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: white;
        }

        .puzzle-option:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .puzzle-option.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .puzzle-option canvas {
            display: block;
            margin: 0 auto 8px;
        }

        .puzzle-option-label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .captcha-footer {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .status-message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .wizard-container {
                margin: 10px;
            }
            
            .wizard-content {
                padding: 25px;
            }
            
            .puzzle-options {
                grid-template-columns: 1fr;
            }
            
            .captcha-content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="wizard-container">
        <div class="wizard-header">
            <h1>🚀 MyL.Zip Setup Wizard</h1>
            <p>Let's get you set up with secure device registration</p>
        </div>

        <div class="wizard-content">
            <!-- Step 1: User Information -->
            <div id="step1" class="step active">
                <h2 style="margin-bottom: 20px; color: #333;">Welcome! Let's get started</h2>
                <p style="margin-bottom: 25px; color: #666;">Please provide your information so we can set up your device registration.</p>
                
                <div class="form-group">
                    <label for="initials">Your Initials</label>
                    <input type="text" id="initials" placeholder="e.g., J.D.">
                    <small>This helps us identify your setup</small>
                </div>
                
                <div class="form-group">
                    <label for="email">Email Address (Required) *</label>
                    <input type="email" id="email" placeholder="e.g., john.doe@example.com" required>
                    <small class="email-requirement">Email address is now required for all registered features and content.</small>
                </div>

                <div class="form-group">
                    <label for="deviceId">Device ID (Optional)</label>
                    <input type="text" id="deviceId" placeholder="Enter device ID to sync with existing device">
                    <small>Leave empty to generate a new device ID, or enter an existing one to sync</small>
                </div>

                <div class="device-info">
                    <h3>🔑 Your Device Information</h3>
                    <ul>
                        <li><strong>Device ID:</strong> <span id="displayDeviceId">Loading...</span></li>
                        <li><strong>Registration Domain:</strong> <span id="displayDomain">*.myl.zip</span></li>
                        <li><strong>Security Level:</strong> High (Captcha Required)</li>
                    </ul>
                </div>

                <!-- Cross-Platform Chat Interface -->
                <div class="chat-interface">
                    <h3>💬 Cross-Platform Chat</h3>
                    <p style="margin-bottom: 15px; color: #666; font-size: 14px;">Connect with your Chrome extension and share personalized UI requirements</p>
                    
                    <div class="chat-container">
                        <div class="chat-messages" id="setupChatMessages">
                            <div class="message system">
                                <div class="message-time">Just now</div>
                                <div class="message-content">Welcome to MyL.Zip! This chat connects with your Chrome extension for seamless communication.</div>
                            </div>
                        </div>
                        
                        <div class="chat-input">
                            <input type="text" id="setupChatInput" placeholder="Share UI preferences or ask questions..." maxlength="200">
                            <button type="button" id="setupChatSend" class="btn btn-secondary">Send</button>
                        </div>
                    </div>
                    
                    <div class="chat-status" id="setupChatStatus">
                        <small>🔗 Ready to connect with Chrome extension</small>
                    </div>
                </div>

                <div class="wizard-navigation">
                    <div></div>
                    <button class="btn btn-primary" onclick="nextStep()">Continue →</button>
                </div>
            </div>

            <!-- Step 2: Captcha Verification -->
            <div id="step2" class="step">
                <h2 style="margin-bottom: 20px; color: #333;">Security Verification</h2>
                <p style="margin-bottom: 25px; color: #666;">Please complete this security puzzle to verify you're human.</p>
                
                <div class="status-message status-info" id="captchaStatus">
                    Click the button below to start the security verification.
                </div>

                <div class="wizard-navigation">
                    <button class="btn btn-secondary" onclick="previousStep()">← Back</button>
                    <button class="btn btn-primary" onclick="startCaptcha()">Start Verification</button>
                    <button class="btn btn-secondary" id="skipCaptchaBtn" aria-label="Skip verification and continue" title="Skip verification and continue">Skip for now</button>
                </div>
            </div>

            <!-- Step 3: Completion -->
            <div id="step3" class="step">
                <h2 style="margin-bottom: 20px; color: #333;">Setup Complete! 🎉</h2>
                <p style="margin-bottom: 25px; color: #666;">Your device has been successfully registered with MyL.Zip.</p>
                
                <div class="device-info">
                    <h3>✅ Registration Summary</h3>
                    <ul>
                        <li><strong>Device ID:</strong> <span id="finalDeviceId">Loading...</span></li>
                        <li><strong>User:</strong> <span id="finalUser">Loading...</span></li>
                        <li><strong>Registration Date:</strong> <span id="registrationDate">Loading...</span></li>
                        <li><strong>Status:</strong> <span style="color: #28a745;">Active ✓</span></li>
                    </ul>
                </div>

                <div class="wizard-navigation">
                    <button class="btn btn-secondary" onclick="goToSettings()">Settings</button>
                    <button class="btn btn-primary" onclick="goToHome()">Go to Home</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Captcha Modal -->
    <div class="captcha-modal" id="captchaModal">
        <div class="captcha-content">
            <div class="captcha-header">
                <h2>🔒 Security Verification</h2>
                <p>Please solve this puzzle to continue</p>
            </div>

            <div class="puzzle-container">
                <div class="puzzle-question" id="puzzleQuestion">Loading puzzle...</div>
                <canvas id="puzzleCanvas" width="300" height="150" class="puzzle-canvas"></canvas>
                <div class="puzzle-options" id="puzzleOptions"></div>
            </div>

            <div class="captcha-footer">
                <button class="btn btn-secondary" onclick="closeCaptcha()">Cancel</button>
                <button class="btn btn-primary" id="submitCaptcha" onclick="submitCaptcha()" disabled>Submit Answer</button>
            </div>
        </div>
    </div>

    <!-- Environment Configuration -->
    <script src="js/environment.js"></script>
    
    <script>
        class SetupWizard {
            constructor() {
                this.currentStep = 1;
                this.totalSteps = 3;
                this.userData = {};
                this.deviceId = null;
                this.captcha = null;
                this.init();
            }

            async init() {
                await this.loadDeviceInfo();
                this.setupSyncKeyHandlers();
                this.updateStepDisplay();
                
                // Skip captcha handler for accessibility/testing
                const skipBtn = document.getElementById('skipCaptchaBtn');
                if (skipBtn) {
                    skipBtn.addEventListener('click', () => this.skipVerification());
                }
            }

            async loadDeviceInfo() {
                // Check if user is already registered by email
                const existingEmail = localStorage.getItem('mylzip_user_email');
                
                if (existingEmail) {
                    // User already registered - show settings option
                    this.showAlreadyRegistered();
                    return;
                }

                // Use existing device ID or generate new one only once
                let deviceId = localStorage.getItem('mylzip_device_id');
                if (!deviceId) {
                    deviceId = this.generateDeviceId();
                    localStorage.setItem('mylzip_device_id', deviceId);
                }
                
                this.deviceId = deviceId;
                document.getElementById('displayDeviceId').textContent = this.deviceId;
            }

            generateDeviceId() {
                const timestamp = Date.now().toString(36);
                const random = Math.random().toString(36).substr(2, 9);
                return `myl_${timestamp}_${random}`;
            }

            generateSyncKey() {
                // Generate a secure sync key: 32 characters, alphanumeric + special chars
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
                let result = '';
                for (let i = 0; i < 32; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            setupSyncKeyHandlers() {
                const generateBtn = document.getElementById('generateSyncKey');
                const copyBtn = document.getElementById('copySyncKey');
                const syncKeyInput = document.getElementById('syncKey');

                if (generateBtn) {
                    generateBtn.addEventListener('click', () => {
                        const newKey = this.generateSyncKey();
                        syncKeyInput.value = newKey;
                        localStorage.setItem('mylzip_sync_key', newKey);
                        syncKeyInput.style.background = '#e8f5e8';
                        setTimeout(() => {
                            syncKeyInput.style.background = '#f8f9fa';
                        }, 1000);
                    });
                }

                if (copyBtn) {
                    copyBtn.addEventListener('click', () => {
                        if (syncKeyInput.value) {
                            navigator.clipboard.writeText(syncKeyInput.value).then(() => {
                                copyBtn.textContent = 'Copied!';
                                copyBtn.style.background = '#28a745';
                                setTimeout(() => {
                                    copyBtn.textContent = 'Copy Key';
                                    copyBtn.style.background = '';
                                }, 2000);
                            }).catch(() => {
                                // Fallback for older browsers
                                syncKeyInput.select();
                                document.execCommand('copy');
                                copyBtn.textContent = 'Copied!';
                                setTimeout(() => {
                                    copyBtn.textContent = 'Copy Key';
                                }, 2000);
                            });
                        }
                    });
                }

                // Load existing sync key or generate new one only once
                let existingSyncKey = localStorage.getItem('mylzip_sync_key');
                if (!existingSyncKey) {
                    existingSyncKey = this.generateSyncKey();
                    localStorage.setItem('mylzip_sync_key', existingSyncKey);
                }
                if (syncKeyInput) {
                    syncKeyInput.value = existingSyncKey;
                }
            }

            showAlreadyRegistered() {
                const content = document.querySelector('.wizard-content');
                content.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <h2 style="margin-bottom: 20px; color: #333;">Welcome Back!</h2>
                        <p style="margin-bottom: 30px; color: #666;">You're already registered with MyL.Zip.</p>
                        
                        <div class="device-info">
                            <h3>🔑 Your Account</h3>
                            <ul>
                                <li><strong>Email:</strong> ${localStorage.getItem('mylzip_user_email')}</li>
                                <li><strong>Device ID:</strong> ${localStorage.getItem('mylzip_device_id')}</li>
                                <li><strong>User:</strong> ${localStorage.getItem('mylzip_user_initials') || 'Not specified'}</li>
                                <li><strong>Status:</strong> <span style="color: #28a745;">Active ✓</span></li>
                            </ul>
                        </div>

                        <div class="wizard-navigation">
                            <button class="btn btn-secondary" onclick="sendAuthEmail()">Send Auth Link</button>
                            <button class="btn btn-primary" onclick="goToSettings()">Go to Settings</button>
                        </div>
                    </div>
                `;
            }

            updateStepDisplay() {
                // Hide all steps
                for (let i = 1; i <= this.totalSteps; i++) {
                    document.getElementById(`step${i}`).classList.remove('active');
                }
                
                // Show current step
                document.getElementById(`step${this.currentStep}`).classList.add('active');
            }

            nextStep() {
                if (this.currentStep < this.totalSteps) {
                    this.currentStep++;
                    this.updateStepDisplay();
                }
            }

            previousStep() {
                if (this.currentStep > 1) {
                    this.currentStep--;
                    this.updateStepDisplay();
                }
            }

            startCaptcha() {
                this.captcha = new CaptchaPuzzle();
                this.captcha.showModal();
            }

            skipVerification() {
                try {
                    // Ensure email exists
                    const email = localStorage.getItem('mylzip_user_email');
                    if (!email) {
                        alert('Please complete Step 1 with your email first.');
                        this.currentStep = 1;
                        this.updateStepDisplay();
                        return;
                    }
                    // Mark terms accepted
                    localStorage.setItem('mylzip_terms_accepted', 'true');
                    localStorage.setItem('mylzip_terms_version', '1.0.0');
                    localStorage.setItem('mylzip_terms_timestamp', new Date().toISOString());
                    
                    // Send auth to extension via content script bridge
                    if (window.chrome && chrome.runtime) {
                        const authData = {
                            email,
                            timestamp: new Date().toISOString(),
                            deviceId: localStorage.getItem('mylzip_device_id'),
                            termsAccepted: true,
                            termsVersion: localStorage.getItem('mylzip_terms_version'),
                            termsTimestamp: localStorage.getItem('mylzip_terms_timestamp')
                        };
                        chrome.runtime.sendMessage({ type: 'STORE_EMAIL_AUTH', data: authData }, () => {});
                    }
                    // Continue to completion
                    this.completeSetup();
                } catch (e) {
                    console.log('Skip verification failed:', e.message);
                }
            }

            async completeSetup() {
                // Save user data
                const initials = document.getElementById('initials').value.trim();
                const email = document.getElementById('email').value.trim();
                const deviceIdInput = document.getElementById('deviceId').value.trim();
                
                // Validate required email address
                if (!email) {
                    alert('Email address is required for registration. Please provide a valid email address.');
                    return;
                }
                
                // Validate email format
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(email)) {
                    alert('Please enter a valid email address format.');
                    return;
                }
                
                // Use provided device ID or existing one
                const finalDeviceId = deviceIdInput || this.deviceId;
                
                localStorage.setItem('mylzip_device_id', finalDeviceId);
                localStorage.setItem('mylzip_user_initials', initials);
                localStorage.setItem('mylzip_user_email', email); // Now always required
                localStorage.setItem('mylzip_registration_date', new Date().toISOString());

                // Update final display
                document.getElementById('finalDeviceId').textContent = finalDeviceId;
                document.getElementById('finalUser').textContent = `${initials || 'Not specified'} (${email})`;
                document.getElementById('registrationDate').textContent = new Date().toLocaleDateString();

                this.nextStep();
            }
        }

        class CaptchaPuzzle {
            constructor() {
                this.currentPuzzle = null;
                this.selectedAnswer = null;
                this.puzzles = [
                    {
                        question: 'Click the RED CIRCLE',
                        type: 'shape',
                        target: 'circle',
                        color: 'red'
                    },
                    {
                        question: 'Click the BLUE TRIANGLE',
                        type: 'shape',
                        target: 'triangle',
                        color: 'blue'
                    },
                    {
                        question: 'Click the GREEN SQUARE',
                        type: 'shape',
                        target: 'square',
                        color: 'green'
                    },
                    {
                        question: 'Complete the pattern: Triangle → Square → Pentagon → ?',
                        type: 'pattern',
                        target: 'hexagon'
                    },
                    {
                        question: 'Click the shape pointing UP',
                        type: 'direction',
                        target: 'up'
                    }
                ];
            }

            showModal() {
                document.getElementById('captchaModal').style.display = 'flex';
                this.generatePuzzle();
            }

            closeModal() {
                document.getElementById('captchaModal').style.display = 'none';
                this.selectedAnswer = null;
                document.getElementById('submitCaptcha').disabled = true;
            }

            generatePuzzle() {
                this.currentPuzzle = this.puzzles[Math.floor(Math.random() * this.puzzles.length)];
                this.renderPuzzle();
            }

            renderPuzzle() {
                const canvas = document.getElementById('puzzleCanvas');
                const ctx = canvas.getContext('2d');
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw puzzle based on type
                if (this.currentPuzzle.type === 'shape') {
                    this.drawShapePuzzle(ctx);
                } else if (this.currentPuzzle.type === 'pattern') {
                    this.drawPatternPuzzle(ctx);
                } else if (this.currentPuzzle.type === 'direction') {
                    this.drawDirectionPuzzle(ctx);
                }

                // Update question
                document.getElementById('puzzleQuestion').textContent = this.currentPuzzle.question;
                
                // Generate options
                this.generateOptions();
            }

            drawShapePuzzle(ctx) {
                const canvas = document.getElementById('puzzleCanvas');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const size = 40;
                
                // Draw the target shape
                ctx.strokeStyle = this.currentPuzzle.color;
                ctx.fillStyle = this.currentPuzzle.color;
                ctx.lineWidth = 3;
                
                if (this.currentPuzzle.target === 'circle') {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, size, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (this.currentPuzzle.target === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - size);
                    ctx.lineTo(centerX - size, centerY + size);
                    ctx.lineTo(centerX + size, centerY + size);
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.currentPuzzle.target === 'square') {
                    ctx.strokeRect(centerX - size, centerY - size, size * 2, size * 2);
                }
            }

            drawPatternPuzzle(ctx) {
                const canvas = document.getElementById('puzzleCanvas');
                const shapes = ['triangle', 'square', 'pentagon', 'hexagon'];
                const spacing = 60;
                const startX = 50;
                const centerY = canvas.height / 2;
                
                shapes.forEach((shape, index) => {
                    const x = startX + (index * spacing);
                    ctx.strokeStyle = '#333';
                    ctx.fillStyle = '#333';
                    ctx.lineWidth = 2;
                    
                    if (shape === 'triangle') {
                        ctx.beginPath();
                        ctx.moveTo(x, centerY - 20);
                        ctx.lineTo(x - 15, centerY + 20);
                        ctx.lineTo(x + 15, centerY + 20);
                        ctx.closePath();
                        ctx.stroke();
                    } else if (shape === 'square') {
                        ctx.strokeRect(x - 15, centerY - 15, 30, 30);
                    } else if (shape === 'pentagon') {
                        this.drawPolygon(ctx, x, centerY, 15, 5);
                    } else if (shape === 'hexagon') {
                        this.drawPolygon(ctx, x, centerY, 15, 6);
                    }
                });
            }

            drawDirectionPuzzle(ctx) {
                const canvas = document.getElementById('puzzleCanvas');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const size = 30;
                
                // Draw arrow pointing up
                ctx.strokeStyle = '#333';
                ctx.fillStyle = '#333';
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - size);
                ctx.lineTo(centerX, centerY + size);
                ctx.moveTo(centerX - 10, centerY + size - 10);
                ctx.lineTo(centerX, centerY + size);
                ctx.lineTo(centerX + 10, centerY + size - 10);
                ctx.stroke();
            }

            drawPolygon(ctx, x, y, radius, sides) {
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
                    const px = x + radius * Math.cos(angle);
                    const py = y + radius * Math.sin(angle);
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.closePath();
                ctx.stroke();
            }

            generateOptions() {
                const optionsContainer = document.getElementById('puzzleOptions');
                optionsContainer.innerHTML = '';
                
                let options = [];
                
                if (this.currentPuzzle.type === 'shape') {
                    const shapes = ['circle', 'triangle', 'square', 'pentagon'];
                    const colors = ['red', 'blue', 'green', 'purple'];
                    
                    // Create 4 options with the correct one included
                    options = [
                        { shape: this.currentPuzzle.target, color: this.currentPuzzle.color },
                        { shape: shapes[Math.floor(Math.random() * shapes.length)], color: colors[Math.floor(Math.random() * colors.length)] },
                        { shape: shapes[Math.floor(Math.random() * shapes.length)], color: colors[Math.floor(Math.random() * colors.length)] },
                        { shape: shapes[Math.floor(Math.random() * shapes.length)], color: colors[Math.floor(Math.random() * colors.length)] }
                    ];
                    
                    // Shuffle options
                    for (let i = options.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [options[i], options[j]] = [options[j], options[i]];
                    }
                } else if (this.currentPuzzle.type === 'pattern') {
                    const shapes = ['triangle', 'square', 'pentagon', 'hexagon', 'octagon'];
                    options = [
                        this.currentPuzzle.target,
                        shapes[Math.floor(Math.random() * shapes.length)],
                        shapes[Math.floor(Math.random() * shapes.length)],
                        shapes[Math.floor(Math.random() * shapes.length)]
                    ];
                    
                    // Shuffle options
                    for (let i = options.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [options[i], options[j]] = [options[j], options[i]];
                    }
                } else if (this.currentPuzzle.type === 'direction') {
                    const directions = ['up', 'down', 'left', 'right'];
                    options = [
                        this.currentPuzzle.target,
                        directions[Math.floor(Math.random() * directions.length)],
                        directions[Math.floor(Math.random() * directions.length)],
                        directions[Math.floor(Math.random() * directions.length)]
                    ];
                    
                    // Shuffle options
                    for (let i = options.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [options[i], options[j]] = [options[j], options[i]];
                    }
                }
                
                options.forEach((option, index) => {
                    const optionElement = document.createElement('div');
                    optionElement.className = 'puzzle-option';
                    optionElement.onclick = () => this.selectOption(index);
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 60;
                    canvas.height = 60;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw option
                    if (this.currentPuzzle.type === 'shape') {
                        this.drawOptionShape(ctx, option.shape, option.color);
                    } else if (this.currentPuzzle.type === 'pattern') {
                        this.drawOptionShape(ctx, option, '#333');
                    } else if (this.currentPuzzle.type === 'direction') {
                        this.drawOptionDirection(ctx, option);
                    }
                    
                    const label = document.createElement('div');
                    label.className = 'puzzle-option-label';
                    label.textContent = this.getOptionLabel(option);
                    
                    optionElement.appendChild(canvas);
                    optionElement.appendChild(label);
                    optionsContainer.appendChild(optionElement);
                });
            }

            drawOptionShape(ctx, shape, color) {
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 2;
                
                const centerX = 30;
                const centerY = 30;
                const size = 20;
                
                if (shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, size, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (shape === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - size);
                    ctx.lineTo(centerX - size, centerY + size);
                    ctx.lineTo(centerX + size, centerY + size);
                    ctx.closePath();
                    ctx.stroke();
                } else if (shape === 'square') {
                    ctx.strokeRect(centerX - size, centerY - size, size * 2, size * 2);
                } else if (shape === 'pentagon') {
                    this.drawPolygon(ctx, centerX, centerY, size, 5);
                } else if (shape === 'hexagon') {
                    this.drawPolygon(ctx, centerX, centerY, size, 6);
                } else if (shape === 'octagon') {
                    this.drawPolygon(ctx, centerX, centerY, size, 8);
                }
            }

            drawOptionDirection(ctx, direction) {
                ctx.strokeStyle = '#333';
                ctx.fillStyle = '#333';
                ctx.lineWidth = 2;
                
                const centerX = 30;
                const centerY = 30;
                const size = 20;
                
                ctx.beginPath();
                
                if (direction === 'up') {
                    ctx.moveTo(centerX, centerY - size);
                    ctx.lineTo(centerX, centerY + size);
                    ctx.moveTo(centerX - 8, centerY + size - 8);
                    ctx.lineTo(centerX, centerY + size);
                    ctx.lineTo(centerX + 8, centerY + size - 8);
                } else if (direction === 'down') {
                    ctx.moveTo(centerX, centerY - size);
                    ctx.lineTo(centerX, centerY + size);
                    ctx.moveTo(centerX - 8, centerY - size + 8);
                    ctx.lineTo(centerX, centerY - size);
                    ctx.lineTo(centerX + 8, centerY - size + 8);
                } else if (direction === 'left') {
                    ctx.moveTo(centerX - size, centerY);
                    ctx.lineTo(centerX + size, centerY);
                    ctx.moveTo(centerX - size + 8, centerY - 8);
                    ctx.lineTo(centerX - size, centerY);
                    ctx.lineTo(centerX - size + 8, centerY + 8);
                } else if (direction === 'right') {
                    ctx.moveTo(centerX - size, centerY);
                    ctx.lineTo(centerX + size, centerY);
                    ctx.moveTo(centerX + size - 8, centerY - 8);
                    ctx.lineTo(centerX + size, centerY);
                    ctx.lineTo(centerX + size - 8, centerY + 8);
                }
                
                ctx.stroke();
            }

            getOptionLabel(option) {
                if (typeof option === 'object' && option.shape) {
                    return `${option.color.charAt(0).toUpperCase() + option.color.slice(1)} ${option.shape.charAt(0).toUpperCase() + option.shape.slice(1)}`;
                } else if (typeof option === 'string') {
                    return option.charAt(0).toUpperCase() + option.slice(1);
                }
                return 'Option';
            }

            selectOption(index) {
                // Remove previous selection
                document.querySelectorAll('.puzzle-option').forEach(option => {
                    option.classList.remove('selected');
                });
                
                // Select new option
                document.querySelectorAll('.puzzle-option')[index].classList.add('selected');
                this.selectedAnswer = index;
                
                // Enable submit button
                document.getElementById('submitCaptcha').disabled = false;
            }

                         submitCaptcha() {
                 if (this.selectedAnswer === null) return;
                 
                 // Check if answer is correct
                 const options = document.querySelectorAll('.puzzle-option');
                 const selectedOption = options[this.selectedAnswer];
                 const label = selectedOption.querySelector('.puzzle-option-label').textContent;
                 
                 let isCorrect = false;
                 
                 if (this.currentPuzzle.type === 'shape') {
                     const targetLabel = `${this.currentPuzzle.color.charAt(0).toUpperCase() + this.currentPuzzle.color.slice(1)} ${this.currentPuzzle.target.charAt(0).toUpperCase() + this.currentPuzzle.target.slice(1)}`;
                     isCorrect = label === targetLabel;
                 } else if (this.currentPuzzle.type === 'pattern') {
                     isCorrect = label.toLowerCase() === this.currentPuzzle.target;
                 } else if (this.currentPuzzle.type === 'direction') {
                     isCorrect = label.toLowerCase() === this.currentPuzzle.target;
                 }
                 
                 if (isCorrect) {
                     // Store terms acceptance in localStorage for cross-device sync
                     localStorage.setItem('mylzip_terms_accepted', 'true');
                     localStorage.setItem('mylzip_terms_version', '1.0');
                     localStorage.setItem('mylzip_terms_timestamp', new Date().toISOString());
                     
                     // Send authentication data to Chrome extension if available
                     this.sendAuthToExtension();
                     
                     this.closeModal();
                     setupWizard.completeSetup();
                 } else {
                     // Show error and generate new puzzle
                     alert('Incorrect answer. Please try again.');
                     this.generatePuzzle();
                     this.selectedAnswer = null;
                     document.getElementById('submitCaptcha').disabled = true;
                 }
             }

             sendAuthToExtension() {
                 try {
                     console.log('📧 Sending authentication data to Chrome extension...');
                     
                     const email = document.getElementById('email').value.trim();
                     const deviceId = setupWizard.deviceId;
                     const timestamp = new Date().toISOString();
                     
                     const authData = {
                         email: email,
                         timestamp: timestamp,
                         deviceId: deviceId,
                         termsAccepted: true,
                         termsVersion: '1.0.0',
                         termsTimestamp: timestamp
                     };
                     
                     // Try to send to Chrome extension via content script
                     if (window.chrome && chrome.runtime) {
                         chrome.runtime.sendMessage({
                             type: 'STORE_EMAIL_AUTH',
                             data: authData
                         }, (response) => {
                             if (response && response.success) {
                                 console.log('✅ Authentication data sent to extension successfully');
                             } else {
                                 console.log('⚠️ Failed to send auth data to extension:', response);
                             }
                         });
                     } else {
                         console.log('⚠️ Chrome extension not available');
                     }
                 } catch (error) {
                     console.error('❌ Error sending auth data to extension:', error);
                 }
             }
        }

        // Initialize setup wizard
        const setupWizard = new SetupWizard();

        // Global functions for navigation
        function nextStep() {
            setupWizard.nextStep();
        }

        function previousStep() {
            setupWizard.previousStep();
        }

        function startCaptcha() {
            setupWizard.startCaptcha();
        }

        function closeCaptcha() {
            setupWizard.captcha.closeModal();
        }

        function submitCaptcha() {
            setupWizard.captcha.submitCaptcha();
        }

        function goToSettings() {
            window.location.href = '/settings.html';
        }

        function goToHome() {
            window.location.href = '/';
        }

        function sendAuthEmail() {
            const email = localStorage.getItem('mylzip_user_email');
            if (!email) {
                alert('No email address found. Please complete setup first.');
                return;
            }

            // Generate authentication token
            const authToken = generateAuthToken();
            // Use environment-based URL
            const authUrl = window.webEnvironmentConfig ? 
              window.webEnvironmentConfig.getAuthUrl({ token: authToken, email: email }) : 
              `http://localhost:8080/auth.html?token=${authToken}&email=${encodeURIComponent(email)}`;
            
            // Store auth token temporarily
            localStorage.setItem('mylzip_auth_token', authToken);
            localStorage.setItem('mylzip_auth_email', email);
            
            // In a real implementation, this would send an actual email
            // For now, we'll show the link and copy it to clipboard
            const message = `Authentication link for ${email}:\n\n${authUrl}\n\nThis link will allow you to authenticate from any device.`;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(authUrl).then(() => {
                    alert(`Authentication link copied to clipboard!\n\n${message}\n\nIn production, this link would be emailed to ${email}.`);
                });
            } else {
                alert(`Authentication link:\n\n${message}\n\nIn production, this link would be emailed to ${email}.`);
            }
        }

        function generateAuthToken() {
            const timestamp = Date.now().toString(36);
            const random = Math.random().toString(36).substr(2, 9);
            return `auth_${timestamp}_${random}`;
        }

        // Cross-Platform Chat System
        class CrossPlatformChat {
            constructor() {
                this.messages = [];
                this.deviceId = null;
                this.userEmail = null;
                this.syncKey = null;
                this.isConnected = false;
                this.connectionInterval = null;
                this.init();
            }

            init() {
                console.log('💬 Cross-Platform Chat: Initializing...');
                this.setupEventListeners();
                this.loadDeviceData();
                this.loadChatHistory(); // Load persistent chat history
                this.startConnectionCheck();
            }

            setupEventListeners() {
                const sendBtn = document.getElementById('setupChatSend');
                const input = document.getElementById('setupChatInput');

                if (sendBtn) {
                    sendBtn.addEventListener('click', () => this.sendMessage());
                }

                if (input) {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.sendMessage();
                        }
                    });
                }
            }

            loadDeviceData() {
                // Load device data from localStorage
                this.deviceId = localStorage.getItem('mylzip_device_id');
                this.userEmail = localStorage.getItem('mylzip_user_email');
                this.syncKey = localStorage.getItem('mylzip_sync_key');

                console.log('💬 Chat device data loaded:', {
                    deviceId: this.deviceId,
                    userEmail: this.userEmail,
                    syncKey: this.syncKey
                });
            }

            loadChatHistory() {
                try {
                    // Generate a unique chat session key based on device and user agent
                    const userAgent = navigator.userAgent;
                    const sessionKey = this.generateSessionKey();
                    
                    // Load chat history from localStorage
                    const chatHistory = localStorage.getItem(`mylzip_chat_history_${sessionKey}`);
                    
                    if (chatHistory) {
                        this.messages = JSON.parse(chatHistory);
                        console.log('💬 Chat history loaded:', this.messages.length, 'messages');
                        
                        // Display all loaded messages
                        this.messages.forEach(msg => this.displayMessage(msg));
                    } else {
                        console.log('💬 No previous chat history found');
                        this.messages = [];
                    }
                } catch (error) {
                    console.error('💬 Error loading chat history:', error);
                    this.messages = [];
                }
            }

            saveChatHistory() {
                try {
                    const sessionKey = this.generateSessionKey();
                    const chatData = {
                        messages: this.messages,
                        lastUpdated: new Date().toISOString(),
                        deviceId: this.deviceId,
                        userEmail: this.userEmail,
                        userAgent: navigator.userAgent
                    };
                    
                    localStorage.setItem(`mylzip_chat_history_${sessionKey}`, JSON.stringify(chatData));
                    console.log('💬 Chat history saved:', this.messages.length, 'messages');
                } catch (error) {
                    console.error('💬 Error saving chat history:', error);
                }
            }

            generateSessionKey() {
                // Create a unique session key based on device ID and user agent
                const deviceId = this.deviceId || 'unknown';
                const userAgent = navigator.userAgent;
                const userEmail = this.userEmail || 'anonymous';
                
                // Create a hash-like key
                const keyString = `${deviceId}_${userEmail}_${userAgent}`;
                let hash = 0;
                for (let i = 0; i < keyString.length; i++) {
                    const char = keyString.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                
                return `session_${Math.abs(hash)}`;
            }

            startConnectionCheck() {
                // Check for Chrome extension connection every 5 seconds
                this.connectionInterval = setInterval(() => {
                    this.checkExtensionConnection();
                }, 5000);

                // Initial check
                this.checkExtensionConnection();
            }

            checkExtensionConnection() {
                // Check if Chrome extension is available and connected
                if (window.chrome && chrome.runtime) {
                    // Try to communicate with extension
                    chrome.runtime.sendMessage({
                        type: 'CHAT_CONNECTION_CHECK',
                        source: 'setup-wizard',
                        deviceId: this.deviceId,
                        userEmail: this.userEmail
                    }, (response) => {
                        if (chrome.runtime.lastError) {
                            this.updateConnectionStatus(false);
                        } else if (response && response.connected) {
                            this.updateConnectionStatus(true);
                            this.syncMessages(response.messages || []);
                        }
                    });
                } else {
                    this.updateConnectionStatus(false);
                }
            }

            updateConnectionStatus(connected) {
                this.isConnected = connected;
                const statusElement = document.getElementById('setupChatStatus');
                
                if (statusElement) {
                    statusElement.className = `chat-status ${connected ? 'connected' : 'disconnected'}`;
                    statusElement.innerHTML = connected ? 
                        '<small>✅ Connected to Chrome extension</small>' : 
                        '<small>🔗 Ready to connect with Chrome extension</small>';
                }

                console.log('💬 Chat connection status:', connected);
            }

            sendMessage() {
                const input = document.getElementById('setupChatInput');
                const message = input?.value.trim();

                if (!message) return;

                const chatMessage = {
                    id: this.generateMessageId(),
                    timestamp: new Date().toISOString(),
                    type: 'user',
                    content: message,
                    source: 'setup-wizard',
                    deviceId: this.deviceId,
                    userEmail: this.userEmail
                };

                // Add to local messages
                this.messages.push(chatMessage);
                this.displayMessage(chatMessage);
                this.saveChatHistory(); // Save chat history immediately

                // Clear input
                if (input) {
                    input.value = '';
                }

                // Send to Chrome extension if connected
                if (this.isConnected && window.chrome && chrome.runtime) {
                    chrome.runtime.sendMessage({
                        type: 'CHAT_MESSAGE',
                        message: chatMessage
                    }, (response) => {
                        if (response && response.success) {
                            console.log('✅ Message sent to extension');
                        }
                    });
                }

                // Send to backend for cross-platform sync
                this.sendToBackend(chatMessage);

                // Generate AI response for UI requirements
                this.generateAIResponse(message);
            }

            displayMessage(message) {
                const messagesContainer = document.getElementById('setupChatMessages');
                if (!messagesContainer) return;

                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${message.type}`;
                messageDiv.innerHTML = `
                    <div class="message-time">${this.formatTime(message.timestamp)}</div>
                    <div class="message-content">${this.escapeHtml(message.content)}</div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            syncMessages(extensionMessages) {
                // Sync messages from Chrome extension
                extensionMessages.forEach(msg => {
                    if (!this.messages.find(m => m.id === msg.id)) {
                        this.messages.push(msg);
                        this.displayMessage(msg);
                    }
                });
            }

            generateAIResponse(userMessage) {
                // AI response system for UI requirements and personalized features
                const responses = {
                    'ui': 'I understand your UI preferences! I\'ll share these with your Chrome extension for a personalized experience.',
                    'theme': 'Great choice! I\'ll sync your theme preferences across all your devices.',
                    'layout': 'Your layout preferences have been noted and will be applied to your extension interface.',
                    'accessibility': 'Accessibility settings are important! I\'ll ensure these are prioritized in your personalized UI.',
                    'color': 'Color preferences saved! These will be reflected in your extension\'s visual design.',
                    'font': 'Font size and style preferences recorded for better readability.',
                    'notification': 'Notification preferences updated! You\'ll get alerts based on your chosen settings.'
                };

                let response = 'Thanks for sharing! I\'ll help personalize your experience across all devices.';
                
                const lowerMessage = userMessage.toLowerCase();
                for (const [key, value] of Object.entries(responses)) {
                    if (lowerMessage.includes(key)) {
                        response = value;
                        break;
                    }
                }

                // Add AI response
                setTimeout(() => {
                    const aiMessage = {
                        id: this.generateMessageId(),
                        timestamp: new Date().toISOString(),
                        type: 'system',
                        content: response,
                        source: 'ai-assistant'
                    };

                    this.messages.push(aiMessage);
                    this.displayMessage(aiMessage);
                    this.saveChatHistory(); // Save chat history after AI response
                }, 1000);
            }

            sendToBackend(message) {
                // Send message to backend for cross-platform synchronization
                fetch('/api/chat/message', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: message,
                        deviceId: this.deviceId,
                        userEmail: this.userEmail,
                        syncKey: this.syncKey
                    })
                }).catch(error => {
                    console.log('💬 Backend sync (optional):', error.message);
                });
            }

            generateMessageId() {
                return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            formatTime(timestamp) {
                return new Date(timestamp).toLocaleTimeString();
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            destroy() {
                if (this.connectionInterval) {
                    clearInterval(this.connectionInterval);
                }
            }
        }

        // Initialize cross-platform chat
        const crossPlatformChat = new CrossPlatformChat();
    </script>
</body>
</html>
